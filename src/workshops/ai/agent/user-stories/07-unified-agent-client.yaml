feature:
  id: "07"
  name: "Unified AgentClient Class"
  priority: "P0"
  story_points: 8
  estimated_hours: 16

dependencies:
  - "@captify-io/core/services/agent"
  - "@captify-io/core/services/aws/bedrock"

services_required:
  - "@captify-io/core/services/agent/captify"
  - "@captify-io/core/services/agent/bedrock"
  - "@captify-io/core/lib/api"

aws_services: []

tables: []

indexes: []

stories:
  - id: "US-07-01"
    title: "Create unified AgentClient interface"
    as_a: "developer"
    i_want: "a single client class that works with all agent types"
    so_that: "I can switch agent modes without changing my code"

    acceptance_criteria:
      - condition: "When I create an AgentClient instance"
        expected: "It provides sendMessage, streamMessage, and loadTools methods"
        test: "expect(client.sendMessage).toBeDefined()"

      - condition: "When I switch agent modes"
        expected: "The same methods work with the new mode"
        test: "expect(client.setMode('aws-agent')).resolves.toBeUndefined()"

      - condition: "When I call sendMessage"
        expected: "It returns a Promise with the response"
        test: "expect(await client.sendMessage('Hello')).toHaveProperty('content')"

    test_scenarios:
      - name: "should create client with default settings"
        type: "unit"
        arrange:
          input:
            mode: "assistant"
        act: "const client = new AgentClient({ mode: input.mode })"
        assert:
          - "expect(client).toBeDefined()"
          - "expect(client.sendMessage).toBeDefined()"
          - "expect(client.streamMessage).toBeDefined()"
          - "expect(client.loadTools).toBeDefined()"

      - name: "should send message and return response"
        type: "integration"
        arrange:
          input:
            mode: "assistant"
            message: "Hello, world!"
          mocks:
            ai.streamText:
              resolves:
                content: "Hello! How can I help you?"
        act: |
          const client = new AgentClient({ mode: input.mode })
          const response = await client.sendMessage(input.message)
        assert:
          - "expect(response).toHaveProperty('content')"
          - "expect(response.content).toBe('Hello! How can I help you?')"

      - name: "should switch modes dynamically"
        type: "unit"
        arrange:
          input:
            initialMode: "assistant"
            newMode: "captify-agent"
        act: |
          const client = new AgentClient({ mode: input.initialMode })
          await client.setMode(input.newMode)
        assert:
          - "expect(client.getMode()).toBe(input.newMode)"

  - id: "US-07-02"
    title: "Implement assistant mode adapter"
    as_a: "developer"
    i_want: "to use AgentClient with basic assistant mode"
    so_that: "I can have simple conversations without tools"

    acceptance_criteria:
      - condition: "When mode is 'assistant'"
        expected: "Messages use AI SDK streamText with no tools"
        test: "expect(ai.streamText).toHaveBeenCalledWith(expect.not.objectContaining({ tools: expect.anything() }))"

      - condition: "When streaming assistant response"
        expected: "Text chunks are yielded progressively"
        test: "expect(stream.textStream).toBeDefined()"

      - condition: "When assistant response completes"
        expected: "Full message is returned with metadata"
        test: "expect(response).toHaveProperty('finishReason', 'stop')"

    test_scenarios:
      - name: "should use streamText for assistant mode"
        type: "integration"
        arrange:
          input:
            mode: "assistant"
            message: "What is 2+2?"
          mocks:
            ai.streamText:
              resolves:
                textStream: ["4"]
                finishReason: "stop"
        act: |
          const client = new AgentClient({ mode: input.mode })
          const response = await client.sendMessage(input.message)
        assert:
          - "expect(ai.streamText).toHaveBeenCalled()"
          - "expect(ai.streamText).toHaveBeenCalledWith(expect.objectContaining({ prompt: input.message }))"
          - "expect(response.content).toBe('4')"

      - name: "should stream assistant responses"
        type: "integration"
        arrange:
          input:
            mode: "assistant"
            message: "Count to 3"
          mocks:
            ai.streamText:
              resolves:
                textStream: ["1", " 2", " 3"]
        act: |
          const client = new AgentClient({ mode: input.mode })
          const stream = await client.streamMessage(input.message)
          const chunks = []
          for await (const chunk of stream) {
            chunks.push(chunk)
          }
        assert:
          - "expect(chunks).toHaveLength(3)"
          - "expect(chunks).toEqual(['1', ' 2', ' 3'])"

      - name: "should not include tools in assistant mode"
        type: "unit"
        arrange:
          input:
            mode: "assistant"
            message: "Hello"
        act: |
          const client = new AgentClient({ mode: input.mode })
          await client.sendMessage(input.message)
        assert:
          - "expect(ai.streamText).toHaveBeenCalledWith(expect.not.objectContaining({ tools: expect.anything() }))"

  - id: "US-07-03"
    title: "Implement captify-agent mode adapter"
    as_a: "developer"
    i_want: "to use AgentClient with captify-agent mode"
    so_that: "I can access memory, search, and custom tools"

    acceptance_criteria:
      - condition: "When mode is 'captify-agent'"
        expected: "Client uses captify.ts service with tools"
        test: "expect(captifyAgent.run).toHaveBeenCalled()"

      - condition: "When loading tools"
        expected: "Custom tools are registered and available"
        test: "expect(client.getAvailableTools()).toContain('search')"

      - condition: "When agent uses a tool"
        expected: "Tool is executed and result included in response"
        test: "expect(response.toolCalls).toContainEqual(expect.objectContaining({ name: 'search' }))"

    test_scenarios:
      - name: "should use captify service for captify-agent mode"
        type: "integration"
        arrange:
          input:
            mode: "captify-agent"
            message: "Search for contracts"
            threadId: "thread-123"
          mocks:
            captifyAgent.run:
              resolves:
                content: "Found 5 contracts"
                toolCalls: []
        act: |
          const client = new AgentClient({ mode: input.mode, threadId: input.threadId })
          const response = await client.sendMessage(input.message)
        assert:
          - "expect(captifyAgent.run).toHaveBeenCalled()"
          - "expect(response.content).toBe('Found 5 contracts')"

      - name: "should load custom tools in captify-agent mode"
        type: "unit"
        arrange:
          input:
            mode: "captify-agent"
            tools:
              - name: "search"
                description: "Search documents"
        act: |
          const client = new AgentClient({ mode: input.mode })
          await client.loadTools(input.tools)
          const availableTools = client.getAvailableTools()
        assert:
          - "expect(availableTools).toContain('search')"

      - name: "should execute tool calls in captify-agent mode"
        type: "integration"
        arrange:
          input:
            mode: "captify-agent"
            message: "Search for user Alice"
          mocks:
            captifyAgent.run:
              resolves:
                content: "Found user Alice"
                toolCalls:
                  - name: "search"
                    args:
                      query: "Alice"
                    result: "Alice (alice@example.com)"
        act: |
          const client = new AgentClient({ mode: input.mode })
          const response = await client.sendMessage(input.message)
        assert:
          - "expect(response.toolCalls).toHaveLength(1)"
          - "expect(response.toolCalls[0].name).toBe('search')"

  - id: "US-07-04"
    title: "Implement aws-agent mode adapter"
    as_a: "developer"
    i_want: "to use AgentClient with AWS Bedrock agents"
    so_that: "I can leverage enterprise agent capabilities"

    acceptance_criteria:
      - condition: "When mode is 'aws-agent'"
        expected: "Client uses Bedrock agent service"
        test: "expect(bedrockAgent.invokeAgent).toHaveBeenCalled()"

      - condition: "When specifying agent ID"
        expected: "Correct Bedrock agent is invoked"
        test: "expect(bedrockAgent.invokeAgent).toHaveBeenCalledWith(expect.objectContaining({ agentId: 'agent-123' }))"

      - condition: "When streaming Bedrock response"
        expected: "Response chunks are yielded progressively"
        test: "expect(stream).toAsyncIterable()"

    test_scenarios:
      - name: "should use Bedrock service for aws-agent mode"
        type: "integration"
        arrange:
          input:
            mode: "aws-agent"
            agentId: "agent-123"
            message: "What is my contract status?"
          mocks:
            bedrockAgent.invokeAgent:
              resolves:
                completion: "Your contract is active"
                sessionId: "session-456"
        act: |
          const client = new AgentClient({ mode: input.mode, agentId: input.agentId })
          const response = await client.sendMessage(input.message)
        assert:
          - "expect(bedrockAgent.invokeAgent).toHaveBeenCalled()"
          - "expect(bedrockAgent.invokeAgent).toHaveBeenCalledWith(expect.objectContaining({ agentId: input.agentId }))"
          - "expect(response.content).toBe('Your contract is active')"

      - name: "should maintain session across messages in aws-agent mode"
        type: "integration"
        arrange:
          input:
            mode: "aws-agent"
            agentId: "agent-123"
            messages:
              - "Hello"
              - "What did I just say?"
          mocks:
            bedrockAgent.invokeAgent:
              resolves:
                - completion: "Hello! How can I help?"
                  sessionId: "session-789"
                - completion: "You said 'Hello'"
                  sessionId: "session-789"
        act: |
          const client = new AgentClient({ mode: input.mode, agentId: input.agentId })
          const response1 = await client.sendMessage(input.messages[0])
          const response2 = await client.sendMessage(input.messages[1])
        assert:
          - "expect(response1.sessionId).toBe('session-789')"
          - "expect(response2.sessionId).toBe('session-789')"
          - "expect(bedrockAgent.invokeAgent).toHaveBeenCalledTimes(2)"

      - name: "should stream Bedrock agent responses"
        type: "integration"
        arrange:
          input:
            mode: "aws-agent"
            agentId: "agent-123"
            message: "Summarize contracts"
          mocks:
            bedrockAgent.invokeAgent:
              resolves:
                stream: ["Contract ", "summary: ", "5 active"]
        act: |
          const client = new AgentClient({ mode: input.mode, agentId: input.agentId })
          const stream = await client.streamMessage(input.message)
          const chunks = []
          for await (const chunk of stream) {
            chunks.push(chunk)
          }
        assert:
          - "expect(chunks).toHaveLength(3)"
          - "expect(chunks.join('')).toBe('Contract summary: 5 active')"

  - id: "US-07-05"
    title: "Create settings manager with validation"
    as_a: "developer"
    i_want: "type-safe settings for each agent mode"
    so_that: "I can configure agents correctly with compile-time safety"

    acceptance_criteria:
      - condition: "When creating client with invalid settings"
        expected: "Validation error is thrown"
        test: "expect(() => new AgentClient({ mode: 'assistant', agentId: 'invalid' })).toThrow()"

      - condition: "When updating settings"
        expected: "Settings are validated before applying"
        test: "expect(client.updateSettings({ temperature: 2.5 })).rejects.toThrow()"

      - condition: "When getting current settings"
        expected: "Typed settings object is returned"
        test: "expect(client.getSettings()).toHaveProperty('temperature')"

    test_scenarios:
      - name: "should validate assistant mode settings"
        type: "unit"
        arrange:
          input:
            mode: "assistant"
            settings:
              model: "gpt-4"
              temperature: 0.7
              maxTokens: 1000
        act: "const client = new AgentClient({ mode: input.mode, ...input.settings })"
        assert:
          - "expect(client.getSettings()).toMatchObject(input.settings)"

      - name: "should reject invalid temperature"
        type: "unit"
        arrange:
          input:
            mode: "assistant"
            settings:
              temperature: 3.0
        act: "const createClient = () => new AgentClient({ mode: input.mode, ...input.settings })"
        assert:
          - "expect(createClient).toThrow()"
          - "expect(createClient).toThrow(/temperature must be between 0 and 2/i)"

      - name: "should validate captify-agent settings"
        type: "unit"
        arrange:
          input:
            mode: "captify-agent"
            settings:
              threadId: "thread-123"
              systemPrompt: "You are a helpful assistant"
              tools:
                - "search"
                - "memory"
        act: "const client = new AgentClient({ mode: input.mode, ...input.settings })"
        assert:
          - "expect(client.getSettings()).toMatchObject(input.settings)"

      - name: "should validate aws-agent settings"
        type: "unit"
        arrange:
          input:
            mode: "aws-agent"
            settings:
              agentId: "agent-123"
              agentAliasId: "alias-456"
        act: "const client = new AgentClient({ mode: input.mode, ...input.settings })"
        assert:
          - "expect(client.getSettings()).toMatchObject(input.settings)"

      - name: "should require agentId for aws-agent mode"
        type: "unit"
        arrange:
          input:
            mode: "aws-agent"
        act: "const createClient = () => new AgentClient({ mode: input.mode })"
        assert:
          - "expect(createClient).toThrow()"
          - "expect(createClient).toThrow(/agentId is required for aws-agent mode/i)"

      - name: "should update settings with validation"
        type: "unit"
        arrange:
          input:
            mode: "assistant"
            initialSettings:
              temperature: 0.7
            newSettings:
              temperature: 0.9
              maxTokens: 2000
        act: |
          const client = new AgentClient({ mode: input.mode, ...input.initialSettings })
          await client.updateSettings(input.newSettings)
        assert:
          - "expect(client.getSettings()).toMatchObject(input.newSettings)"

  - id: "US-07-06"
    title: "Implement unified streaming interface"
    as_a: "developer"
    i_want: "consistent streaming API across all agent modes"
    so_that: "I can build UIs that work with any agent type"

    acceptance_criteria:
      - condition: "When streaming in any mode"
        expected: "AsyncIterable stream is returned"
        test: "expect(stream[Symbol.asyncIterator]).toBeDefined()"

      - condition: "When stream yields chunks"
        expected: "Chunks have consistent format (text, toolCalls, metadata)"
        test: "expect(chunk).toHaveProperty('type')"

      - condition: "When stream completes"
        expected: "Final chunk includes finish reason"
        test: "expect(finalChunk).toHaveProperty('finishReason')"

    test_scenarios:
      - name: "should return async iterable stream"
        type: "unit"
        arrange:
          input:
            mode: "assistant"
            message: "Hello"
        act: |
          const client = new AgentClient({ mode: input.mode })
          const stream = await client.streamMessage(input.message)
        assert:
          - "expect(stream[Symbol.asyncIterator]).toBeDefined()"

      - name: "should yield text chunks in consistent format"
        type: "integration"
        arrange:
          input:
            mode: "assistant"
            message: "Count to 3"
          mocks:
            ai.streamText:
              resolves:
                textStream: ["1", " 2", " 3"]
        act: |
          const client = new AgentClient({ mode: input.mode })
          const stream = await client.streamMessage(input.message)
          const chunks = []
          for await (const chunk of stream) {
            chunks.push(chunk)
          }
        assert:
          - "expect(chunks).toHaveLength(3)"
          - "expect(chunks[0]).toHaveProperty('type', 'text')"
          - "expect(chunks[0]).toHaveProperty('text', '1')"

      - name: "should yield tool call chunks in captify-agent mode"
        type: "integration"
        arrange:
          input:
            mode: "captify-agent"
            message: "Search for Alice"
          mocks:
            captifyAgent.run:
              resolves:
                stream:
                  - type: "tool-call"
                    toolCall:
                      name: "search"
                      args:
                        query: "Alice"
                  - type: "tool-result"
                    toolResult:
                      name: "search"
                      result: "Found Alice"
                  - type: "text"
                    text: "I found Alice in the database"
        act: |
          const client = new AgentClient({ mode: input.mode })
          const stream = await client.streamMessage(input.message)
          const chunks = []
          for await (const chunk of stream) {
            chunks.push(chunk)
          }
        assert:
          - "expect(chunks).toHaveLength(3)"
          - "expect(chunks[0].type).toBe('tool-call')"
          - "expect(chunks[1].type).toBe('tool-result')"
          - "expect(chunks[2].type).toBe('text')"

      - name: "should include finish reason in final chunk"
        type: "integration"
        arrange:
          input:
            mode: "assistant"
            message: "Hello"
          mocks:
            ai.streamText:
              resolves:
                textStream: ["Hi"]
                finishReason: "stop"
        act: |
          const client = new AgentClient({ mode: input.mode })
          const stream = await client.streamMessage(input.message)
          let finalChunk
          for await (const chunk of stream) {
            finalChunk = chunk
          }
        assert:
          - "expect(finalChunk).toHaveProperty('finishReason', 'stop')"

  - id: "US-07-07"
    title: "Implement consistent error handling"
    as_a: "developer"
    i_want: "predictable error handling across all agent modes"
    so_that: "I can gracefully handle failures in my application"

    acceptance_criteria:
      - condition: "When API call fails"
        expected: "AgentError is thrown with error type and details"
        test: "expect(error).toBeInstanceOf(AgentError)"

      - condition: "When rate limit is hit"
        expected: "Error includes retry information"
        test: "expect(error.retryAfter).toBeDefined()"

      - condition: "When validation fails"
        expected: "Error includes validation details"
        test: "expect(error.type).toBe('validation')"

    test_scenarios:
      - name: "should throw AgentError on API failure"
        type: "integration"
        arrange:
          input:
            mode: "assistant"
            message: "Hello"
          mocks:
            ai.streamText:
              rejects:
                error: "API call failed"
        act: |
          const client = new AgentClient({ mode: input.mode })
          const sendMessage = () => client.sendMessage(input.message)
        assert:
          - "await expect(sendMessage()).rejects.toThrow(AgentError)"
          - "await expect(sendMessage()).rejects.toThrow(/API call failed/i)"

      - name: "should include error type in AgentError"
        type: "unit"
        arrange:
          input:
            mode: "assistant"
            message: "Hello"
          mocks:
            ai.streamText:
              rejects:
                error: "Rate limit exceeded"
                status: 429
        act: |
          const client = new AgentClient({ mode: input.mode })
          try {
            await client.sendMessage(input.message)
          } catch (error) {
            return error
          }
        assert:
          - "expect(result).toBeInstanceOf(AgentError)"
          - "expect(result.type).toBe('rate-limit')"
          - "expect(result.retryAfter).toBeDefined()"

      - name: "should throw validation error for invalid settings"
        type: "unit"
        arrange:
          input:
            mode: "assistant"
            settings:
              temperature: 5.0
        act: |
          try {
            new AgentClient({ mode: input.mode, ...input.settings })
          } catch (error) {
            return error
          }
        assert:
          - "expect(result).toBeInstanceOf(AgentError)"
          - "expect(result.type).toBe('validation')"
          - "expect(result.message).toMatch(/temperature/i)"

      - name: "should handle network errors gracefully"
        type: "integration"
        arrange:
          input:
            mode: "captify-agent"
            message: "Hello"
          mocks:
            captifyAgent.run:
              rejects:
                error: "Network error"
                code: "ECONNREFUSED"
        act: |
          const client = new AgentClient({ mode: input.mode })
          try {
            await client.sendMessage(input.message)
          } catch (error) {
            return error
          }
        assert:
          - "expect(result).toBeInstanceOf(AgentError)"
          - "expect(result.type).toBe('network')"
          - "expect(result.code).toBe('ECONNREFUSED')"
